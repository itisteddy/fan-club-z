{"version":3,"file":"secp256k1-3f32b07b.js","sources":["../../node_modules/wagmi/node_modules/@noble/curves/esm/abstract/hash-to-curve.js","../../node_modules/wagmi/node_modules/@noble/curves/esm/secp256k1.js"],"sourcesContent":["import { mod } from './modular.js';\nimport { abytes, bytesToNumberBE, concatBytes, utf8ToBytes, validateObject } from './utils.js';\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << (8 * length))\n        throw new Error('invalid I2OSP input: ' + value);\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nexport function expand_message_xmd(msg, DST, lenInBytes, H) {\n    abytes(msg);\n    abytes(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255)\n        throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H(concatBytes(...args));\n    }\n    const pseudo_random_bytes = concatBytes(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nexport function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    abytes(msg);\n    abytes(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg, count, options) {\n    validateObject(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    abytes(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? utf8ToBytes(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = mod(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nexport function isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x: x, y: y };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */\nexport function createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('mapToCurve: expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error('mapToCurve: expected array of bigints');\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map","/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { createCurve } from './_shortw_utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { aInRange, bytesToNumberBE, concatBytes, ensureBytes, inRange, numberToBytesBE, } from './abstract/utils.js';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n *\n * @example\n * import { secp256k1 } from '@noble/curves/secp256k1';\n *\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n */\nexport const secp256k1 = createCurve({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7),\n    Fp: Fpk1, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = mod(k - c1 * a1 - c2 * a2, n);\n            let k2 = mod(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => numberToBytesBE(n, 32);\nconst modP = (x) => mod(x, secp256k1P);\nconst modN = (x) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    aInRange('x', x, _1n, secp256k1P); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = randomBytes(32)) {\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!inRange(r, _1n, secp256k1P))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!inRange(s, _1n, secp256k1N))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n */\nexport const schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE,\n        bytesToNumberBE,\n        taggedHash,\n        mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\n/** secp256k1 hash-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\n/** secp256k1 encode-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map"],"names":["os2ip","bytesToNumberBE","i2osp","value","length","anum","res","i","strxor","a","b","arr","item","expand_message_xmd","msg","DST","lenInBytes","H","abytes","concatBytes","utf8ToBytes","b_in_bytes","r_in_bytes","ell","DST_prime","Z_pad","l_i_b_str","b_0","args","expand_message_xof","k","dkLen","hash_to_field","count","options","validateObject","p","m","hash","expand","_DST","log2p","L","len_in_bytes","prb","u","e","j","elm_offset","tv","mod","isogenyMap","field","map","COEFF","x","y","xNum","xDen","yNum","yDen","val","acc","createHasher","Point","mapToCurve","def","u0","u1","P","scalars","secp256k1P","secp256k1N","_1n","_2n","divNearest","sqrtMod","_3n","_6n","_11n","_22n","_23n","_44n","_88n","b2","b3","b6","pow2","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","root","Fpk1","Field","secp256k1","createCurve","n","a1","b1","a2","POW_2_128","c1","c2","k1","k2","k1neg","k2neg","sha256","_0n","TAGGED_HASH_PREFIXES","taggedHash","tag","messages","tagP","tagH","c","pointToBytes","point","numTo32b","numberToBytesBE","modP","modN","GmulAdd","Q","schnorrGetExtPubKey","priv","d_","lift_x","aInRange","xx","num","challenge","schnorrGetPublicKey","privateKey","schnorrSign","message","auxRand","randomBytes","ensureBytes","px","d","t","rand","k_","rx","sig","schnorrVerify","signature","publicKey","pub","r","inRange","s","R","schnorr","isoMap","mapSWU","mapToCurveSimpleSWU","htf","hashToCurve","encodeToCurve"],"mappings":"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","x_google_ignoreList":[0,1]}