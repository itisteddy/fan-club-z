import{r as I}from"./vendor-c36eaa8e.js";import{b as B}from"./utils-617af415.js";import{c as D,z as i,f as z,p as $,a as F,al as P,m as h,l as j,am as U,q as k,r as q,s as L,t as H}from"./index-78beacc5.js";import{u as V}from"./useWalletConnectSession-1627a74c.js";import{m as K,r as J,t as Q,v as G,j as S,w as X,B as Y}from"./wagmi-c444efa6.js";const Z=[{type:"function",name:"postSettlementRoot",stateMutability:"nonpayable",inputs:[{name:"predictionId",type:"bytes32"},{name:"root",type:"bytes32"},{name:"creator",type:"address"},{name:"creatorFee",type:"uint256"},{name:"platform",type:"address"},{name:"platformFee",type:"uint256"}],outputs:[]},{type:"function",name:"claim",stateMutability:"nonpayable",inputs:[{name:"predictionId",type:"bytes32"},{name:"amount",type:"uint256"},{name:"proof",type:"bytes32[]"}],outputs:[]}];function ee(s){return`0x${s.replace(/-/g,"").toLowerCase().padEnd(64,"0")}`}function te(s){return Number(s)/1e6}function oe(){const{address:s,chainId:m,isConnected:p}=K(),u=J(),{switchChainAsync:b}=Q(),{writeContractAsync:R}=G(),{withSessionRecovery:A,recoverFromError:T,cleanupWalletConnectSessions:x}=V(),C=B(),{sessionHealthy:v}=D(),[O,f]=I.useState(!1),[_,E]=I.useState(null);async function g(r){if(!q(r))return!1;try{return L(),await T({attemptReconnect:!0}),i.error("Wallet session expired. Please reconnect and try again.",{id:"session-error"}),H("Wallet session expired"),!0}catch{return L(),await x(),i.error("Wallet connection lost. Please reconnect.",{id:"session-error"}),!0}}const M=I.useCallback(async r=>{if(f(!0),E(null),!s||!p)return i.error("Connect your wallet to claim."),f(!1),null;try{z({address:s,chainId:m,expectedChainId:S.id,isConnected:p,sessionHealthy:v})}catch(n){const l=$(n);return i.error(l.message,{id:"claim"}),E(l.message),f(!1),null}let t=null;const y=te(r.amountUnits),a=F.getState().user?.id||"";try{if(!p||!s)return i.error("Connect wallet to claim"),null;m!==S.id&&await b({chainId:S.id});const n=r.escrowAddress||"0x30c60f688A0082D1b761610ec3c70f6dC1374E95";if(!n)throw new Error("Escrow contract address missing (VITE_BASE_ESCROW_ADDRESS)");const l=ee(r.predictionId);i.loading("Submitting claim...",{id:"claim"});try{t=await A(async()=>await R({address:n,abi:Z,functionName:"claim",args:[l,r.amountUnits,r.proof]}),{maxRetries:1,showToast:!1,operationTimeoutMs:2e4})}catch(e){throw P(e)?(i.dismiss("claim"),new Error("Transaction cancelled by user")):await g(e)?new Error("Wallet session expired. Please reconnect and try again."):e}if(!t)throw new Error("Missing transaction hash after claim submission");a&&await h({userId:a,walletAddress:s,txHash:t,type:"claim",status:"pending",amount:y,predictionId:r.predictionId}).catch(e=>{});try{const e=`fcz:lastTx:claim:${r.predictionId}:${s.toLowerCase()}`;localStorage.setItem(e,t),window.dispatchEvent(new CustomEvent("fcz:tx",{detail:{kind:"claim",txHash:t,predictionId:r.predictionId}}))}catch{}i.loading("Waiting for confirmation...",{id:"claim"});let o=!0;if(u)try{(await X(u,{hash:t,confirmations:1,timeout:18e4})).status==="reverted"&&(o=!1,i.error("Claim reverted — settlement root not posted yet or invalid proof",{id:"claim"}))}catch{}if(!o)return a&&await h({userId:a,walletAddress:s,txHash:t,type:"claim",status:"failed",amount:y,predictionId:r.predictionId,error:"Transaction reverted on-chain"}).catch(e=>{}),t;a&&await h({userId:a,walletAddress:s,txHash:t,type:"claim",status:"completed",amount:y,predictionId:r.predictionId}).catch(e=>{});try{if(u&&s){const e=await u.getTransactionReceipt({hash:t}),d="0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",c=`0x000000000000000000000000${s.toLowerCase().slice(2)}`,N=(e?.logs||[]).some(w=>Array.isArray(w.topics)&&w.topics.length>=3&&w.topics[0]===d&&w.topics[2]?.toLowerCase()===c),W=`${t.slice(0,8)}…${t.slice(-6)}`;N?i.success("Claim successful! Tx: "+W,{id:"claim"}):i("Claim mined, but no ERC20 transfer detected. View tx: "+W,{id:"claim"})}else{const e=`${t.slice(0,8)}…${t.slice(-6)}`;i.success("Claim successful! Tx: "+e,{id:"claim"})}}catch{const e=`${t.slice(0,8)}…${t.slice(-6)}`;i.success("Claim successful! Tx: "+e,{id:"claim"})}try{const e=s.toLowerCase();localStorage.setItem(`fcz:claimed:${r.predictionId}:${e}`,"1")}catch{}if(a&&s){const e=j();fetch(`${e}/api/wallet/reconcile`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({userId:a,walletAddress:s,txHash:t})}).then(()=>{}).catch(d=>{})}return U(C,{userId:a,predictionId:r.predictionId}),k(),t}catch(n){const l=await g(n);let o=n?.shortMessage||n?.message||"Claim failed",e=!1;if(n instanceof Y){const c=(n.shortMessage||"").toLowerCase();c.includes("insufficient")&&(o="Insufficient funds to pay gas"),c.includes("user rejected")&&(o="User rejected the transaction"),(c.includes("already claimed")||c.includes("duplicate"))&&(o="Already claimed",e=!0),c.includes("execution reverted")&&(o="Claim reverted — already claimed or invalid proof")}const d=$(n);if(d.code!=="UNKNOWN_ERROR"&&(o=d.message),t&&a&&!l&&!e&&await h({userId:a,walletAddress:s,txHash:t,type:"claim",status:"failed",amount:y,predictionId:r.predictionId,error:o}).catch(c=>{}),e){try{const c=s?.toLowerCase()||"";c&&localStorage.setItem(`fcz:claimed:${r.predictionId}:${c}`,"1")}catch{}return U(C,{userId:a,predictionId:r.predictionId}),i.success("Already claimed",{id:"claim"}),null}else return l||(E(o),i.error(o,{id:"claim"})),null}finally{f(!1)}},[s,m,p,u,b,R,C,A,T,x,v]);return{isClaiming:O,error:_,claim:M}}export{Z as E,oe as u};
