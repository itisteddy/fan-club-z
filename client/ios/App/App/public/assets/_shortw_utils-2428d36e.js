/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Bt=BigInt(0),St=BigInt(1),le=BigInt(2);function it(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function bt(t){if(!it(t))throw new Error("Uint8Array expected")}function lt(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}const de=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function dt(t){bt(t);let n="";for(let e=0;e<t.length;e++)n+=de[t[e]];return n}function ft(t){const n=t.toString(16);return n.length&1?"0"+n:n}function Zt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Bt:BigInt("0x"+t)}const W={_0:48,_9:57,A:65,F:70,a:97,f:102};function Dt(t){if(t>=W._0&&t<=W._9)return t-W._0;if(t>=W.A&&t<=W.F)return t-(W.A-10);if(t>=W.a&&t<=W.f)return t-(W.a-10)}function ht(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let o=0,i=0;o<e;o++,i+=2){const c=Dt(t.charCodeAt(i)),u=Dt(t.charCodeAt(i+1));if(c===void 0||u===void 0){const s=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+i)}r[o]=c*16+u}return r}function rt(t){return Zt(dt(t))}function kt(t){return bt(t),Zt(dt(Uint8Array.from(t).reverse()))}function wt(t,n){return ht(t.toString(16).padStart(n*2,"0"))}function Mt(t,n){return wt(t,n).reverse()}function he(t){return ht(ft(t))}function K(t,n,e){let r;if(typeof n=="string")try{r=ht(n)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else if(it(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(t+" of length "+e+" expected, got "+o);return r}function yt(...t){let n=0;for(let r=0;r<t.length;r++){const o=t[r];bt(o),n+=o.length}const e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){const i=t[r];e.set(i,o),o+=i.length}return e}function we(t,n){if(t.length!==n.length)return!1;let e=0;for(let r=0;r<t.length;r++)e|=t[r]^n[r];return e===0}function ge(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const Nt=t=>typeof t=="bigint"&&Bt<=t;function At(t,n,e){return Nt(t)&&Nt(n)&&Nt(e)&&n<=t&&t<e}function ot(t,n,e,r){if(!At(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function Ft(t){let n;for(n=0;t>Bt;t>>=St,n+=1);return n}function me(t,n){return t>>BigInt(n)&St}function ye(t,n,e){return t|(e?St:Bt)<<BigInt(n)}const jt=t=>(le<<BigInt(t-1))-St,Lt=t=>new Uint8Array(t),$t=t=>Uint8Array.from(t);function te(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Lt(t),o=Lt(t),i=0;const c=()=>{r.fill(1),o.fill(0),i=0},u=(...d)=>e(o,r,...d),s=(d=Lt())=>{o=u($t([0]),d),r=u(),d.length!==0&&(o=u($t([1]),d),r=u())},f=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const h=[];for(;d<n;){r=u();const E=r.slice();h.push(E),d+=r.length}return yt(...h)};return(d,h)=>{c(),s(d);let E;for(;!(E=h(f()));)s();return c(),E}}const be={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||it(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function pt(t,n,e={}){const r=(o,i,c)=>{const u=be[i];if(typeof u!="function")throw new Error("invalid validator function");const s=t[o];if(!(c&&s===void 0)&&!u(s,t))throw new Error("param "+String(o)+" is invalid. Expected "+i+", got "+s)};for(const[o,i]of Object.entries(n))r(o,i,!1);for(const[o,i]of Object.entries(e))r(o,i,!0);return t}const pe=()=>{throw new Error("not implemented")};function Vt(t){const n=new WeakMap;return(e,...r)=>{const o=n.get(e);if(o!==void 0)return o;const i=t(e,...r);return n.set(e,i),i}}const Ee=Object.freeze(Object.defineProperty({__proto__:null,aInRange:ot,abool:lt,abytes:bt,bitGet:me,bitLen:Ft,bitMask:jt,bitSet:ye,bytesToHex:dt,bytesToNumberBE:rt,bytesToNumberLE:kt,concatBytes:yt,createHmacDrbg:te,ensureBytes:K,equalBytes:we,hexToBytes:ht,hexToNumber:Zt,inRange:At,isBytes:it,memoized:Vt,notImplemented:pe,numberToBytesBE:wt,numberToBytesLE:Mt,numberToHexUnpadded:ft,numberToVarBytesBE:he,utf8ToBytes:ge,validateObject:pt},Symbol.toStringTag,{value:"Module"}));function Gt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function xe(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function qt(t,...n){if(!xe(t))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(t.length))throw new Error("Uint8Array expected of length "+n+", got length="+t.length)}function ve(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Gt(t.outputLen),Gt(t.blockLen)}function xt(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function Be(t,n){qt(t);const e=n.outputLen;if(t.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}const at=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ut(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function $(t,n){return t<<32-n|t>>>n}function Se(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function Yt(t){return typeof t=="string"&&(t=Se(t)),qt(t),t}function Ae(...t){let n=0;for(let r=0;r<t.length;r++){const o=t[r];qt(o),n+=o.length}const e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){const i=t[r];e.set(i,o),o+=i.length}return e}class ee{clone(){return this._cloneInto()}}function qe(t){const n=r=>t().update(Yt(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function Oe(t=32){if(at&&typeof at.getRandomValues=="function")return at.getRandomValues(new Uint8Array(t));if(at&&typeof at.randomBytes=="function")return at.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}function Ie(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const o=BigInt(32),i=BigInt(4294967295),c=Number(e>>o&i),u=Number(e&i),s=r?4:0,f=r?0:4;t.setUint32(n+s,c,r),t.setUint32(n+f,u,r)}function Ne(t,n,e){return t&n^~t&e}function Le(t,n,e){return t&n^t&e^n&e}class Ue extends ee{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=Ut(this.buffer)}update(n){xt(this);const{view:e,buffer:r,blockLen:o}=this;n=Yt(n);const i=n.length;for(let c=0;c<i;){const u=Math.min(o-this.pos,i-c);if(u===o){const s=Ut(n);for(;o<=i-c;c+=o)this.process(s,c);continue}r.set(n.subarray(c,c+u),this.pos),this.pos+=u,c+=u,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){xt(this),Be(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:i}=this;let{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(r,0),c=0);for(let d=c;d<o;d++)e[d]=0;Ie(r,o-8,BigInt(this.length*8),i),this.process(r,0);const u=Ut(n),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=s/4,v=this.get();if(f>v.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<f;d++)u.setUint32(4*d,v[d],i)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:i,destroyed:c,pos:u}=this;return n.length=o,n.pos=u,n.finished=i,n.destroyed=c,o%e&&n.buffer.set(r),n}}const He=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Q=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),J=new Uint32Array(64);class Te extends Ue{constructor(){super(64,32,8,!1),this.A=Q[0]|0,this.B=Q[1]|0,this.C=Q[2]|0,this.D=Q[3]|0,this.E=Q[4]|0,this.F=Q[5]|0,this.G=Q[6]|0,this.H=Q[7]|0}get(){const{A:n,B:e,C:r,D:o,E:i,F:c,G:u,H:s}=this;return[n,e,r,o,i,c,u,s]}set(n,e,r,o,i,c,u,s){this.A=n|0,this.B=e|0,this.C=r|0,this.D=o|0,this.E=i|0,this.F=c|0,this.G=u|0,this.H=s|0}process(n,e){for(let d=0;d<16;d++,e+=4)J[d]=n.getUint32(e,!1);for(let d=16;d<64;d++){const h=J[d-15],E=J[d-2],q=$(h,7)^$(h,18)^h>>>3,p=$(E,17)^$(E,19)^E>>>10;J[d]=p+J[d-7]+q+J[d-16]|0}let{A:r,B:o,C:i,D:c,E:u,F:s,G:f,H:v}=this;for(let d=0;d<64;d++){const h=$(u,6)^$(u,11)^$(u,25),E=v+h+Ne(u,s,f)+He[d]+J[d]|0,p=($(r,2)^$(r,13)^$(r,22))+Le(r,o,i)|0;v=f,f=s,s=u,u=c+E|0,c=i,i=o,o=r,r=E+p|0}r=r+this.A|0,o=o+this.B|0,i=i+this.C|0,c=c+this.D|0,u=u+this.E|0,s=s+this.F|0,f=f+this.G|0,v=v+this.H|0,this.set(r,o,i,c,u,s,f,v)}roundClean(){J.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const nn=qe(()=>new Te);class ne extends ee{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,ve(n);const r=Yt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?n.create().update(r).digest():r);for(let c=0;c<i.length;c++)i[c]^=54;this.iHash.update(i),this.oHash=n.create();for(let c=0;c<i.length;c++)i[c]^=106;this.oHash.update(i),i.fill(0)}update(n){return xt(this),this.iHash.update(n),this}digestInto(n){xt(this),qt(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:i,blockLen:c,outputLen:u}=this;return n=n,n.finished=o,n.destroyed=i,n.blockLen=c,n.outputLen=u,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const re=(t,n,e)=>new ne(t,n).update(e).digest();re.create=(t,n)=>new ne(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const V=BigInt(0),R=BigInt(1),nt=BigInt(2),Re=BigInt(3),zt=BigInt(4),Wt=BigInt(5),Pt=BigInt(8);function j(t,n){const e=t%n;return e>=V?e:n+e}function _e(t,n,e){if(n<V)throw new Error("invalid exponent, negatives unsupported");if(e<=V)throw new Error("invalid modulus");if(e===R)return V;let r=R;for(;n>V;)n&R&&(r=r*t%e),t=t*t%e,n>>=R;return r}function rn(t,n,e){let r=t;for(;n-- >V;)r*=r,r%=e;return r}function Ct(t,n){if(t===V)throw new Error("invert: expected non-zero number");if(n<=V)throw new Error("invert: expected positive modulus, got "+n);let e=j(t,n),r=n,o=V,i=R;for(;e!==V;){const u=r/e,s=r%e,f=o-i*u;r=e,e=s,o=i,i=f}if(r!==R)throw new Error("invert: does not exist");return j(o,n)}function Ve(t){const n=(t-R)/nt;let e,r,o;for(e=t-R,r=0;e%nt===V;e/=nt,r++);for(o=nt;o<t&&_e(o,n,t)!==t-R;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const c=(t+R)/zt;return function(s,f){const v=s.pow(f,c);if(!s.eql(s.sqr(v),f))throw new Error("Cannot find square root");return v}}const i=(e+R)/nt;return function(u,s){if(u.pow(s,n)===u.neg(u.ONE))throw new Error("Cannot find square root");let f=r,v=u.pow(u.mul(u.ONE,o),e),d=u.pow(s,i),h=u.pow(s,e);for(;!u.eql(h,u.ONE);){if(u.eql(h,u.ZERO))return u.ZERO;let E=1;for(let p=u.sqr(h);E<f&&!u.eql(p,u.ONE);E++)p=u.sqr(p);const q=u.pow(v,R<<BigInt(f-E-1));v=u.sqr(q),d=u.mul(d,q),h=u.mul(h,v),f=E}return d}}function ze(t){if(t%zt===Re){const n=(t+R)/zt;return function(r,o){const i=r.pow(o,n);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%Pt===Wt){const n=(t-Wt)/Pt;return function(r,o){const i=r.mul(o,nt),c=r.pow(i,n),u=r.mul(o,c),s=r.mul(r.mul(u,nt),c),f=r.mul(u,r.sub(s,r.ONE));if(!r.eql(r.sqr(f),o))throw new Error("Cannot find square root");return f}}return Ve(t)}const Ce=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function oe(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Ce.reduce((r,o)=>(r[o]="function",r),n);return pt(t,e)}function Ze(t,n,e){if(e<V)throw new Error("invalid exponent, negatives unsupported");if(e===V)return t.ONE;if(e===R)return n;let r=t.ONE,o=n;for(;e>V;)e&R&&(r=t.mul(r,o)),o=t.sqr(o),e>>=R;return r}function ke(t,n){const e=new Array(n.length),r=n.reduce((i,c,u)=>t.is0(c)?i:(e[u]=i,t.mul(i,c)),t.ONE),o=t.inv(r);return n.reduceRight((i,c,u)=>t.is0(c)?i:(e[u]=t.mul(i,e[u]),t.mul(i,c)),o),e}function ie(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function Me(t,n,e=!1,r={}){if(t<=V)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:i}=ie(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const u=Object.freeze({ORDER:t,isLE:e,BITS:o,BYTES:i,MASK:jt(o),ZERO:V,ONE:R,create:s=>j(s,t),isValid:s=>{if(typeof s!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof s);return V<=s&&s<t},is0:s=>s===V,isOdd:s=>(s&R)===R,neg:s=>j(-s,t),eql:(s,f)=>s===f,sqr:s=>j(s*s,t),add:(s,f)=>j(s+f,t),sub:(s,f)=>j(s-f,t),mul:(s,f)=>j(s*f,t),pow:(s,f)=>Ze(u,s,f),div:(s,f)=>j(s*Ct(f,t),t),sqrN:s=>s*s,addN:(s,f)=>s+f,subN:(s,f)=>s-f,mulN:(s,f)=>s*f,inv:s=>Ct(s,t),sqrt:r.sqrt||(s=>(c||(c=ze(t)),c(u,s))),invertBatch:s=>ke(u,s),cmov:(s,f,v)=>v?f:s,toBytes:s=>e?Mt(s,i):wt(s,i),fromBytes:s=>{if(s.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+s.length);return e?kt(s):rt(s)}});return Object.freeze(u)}function se(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function ce(t){const n=se(t);return n+Math.ceil(n/2)}function je(t,n,e=!1){const r=t.length,o=se(n),i=ce(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const c=e?kt(t):rt(t),u=j(c,n-R)+R;return e?Mt(u,o):wt(u,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xt=BigInt(0),Et=BigInt(1);function Ht(t,n){const e=n.negate();return t?e:n}function ue(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function Tt(t,n){ue(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1);return{windows:e,windowSize:r}}function Ye(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function Ke(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Rt=new WeakMap,ae=new WeakMap;function _t(t){return ae.get(t)||1}function De(t,n){return{constTimeNegate:Ht,hasPrecomputes(e){return _t(e)!==1},unsafeLadder(e,r,o=t.ZERO){let i=e;for(;r>Xt;)r&Et&&(o=o.add(i)),i=i.double(),r>>=Et;return o},precomputeWindow(e,r){const{windows:o,windowSize:i}=Tt(r,n),c=[];let u=e,s=u;for(let f=0;f<o;f++){s=u,c.push(s);for(let v=1;v<i;v++)s=s.add(u),c.push(s);u=s.double()}return c},wNAF(e,r,o){const{windows:i,windowSize:c}=Tt(e,n);let u=t.ZERO,s=t.BASE;const f=BigInt(2**e-1),v=2**e,d=BigInt(e);for(let h=0;h<i;h++){const E=h*c;let q=Number(o&f);o>>=d,q>c&&(q-=v,o+=Et);const p=E,a=E+Math.abs(q)-1,l=h%2!==0,g=q<0;q===0?s=s.add(Ht(l,r[p])):u=u.add(Ht(g,r[a]))}return{p:u,f:s}},wNAFUnsafe(e,r,o,i=t.ZERO){const{windows:c,windowSize:u}=Tt(e,n),s=BigInt(2**e-1),f=2**e,v=BigInt(e);for(let d=0;d<c;d++){const h=d*u;if(o===Xt)break;let E=Number(o&s);if(o>>=v,E>u&&(E-=f,o+=Et),E===0)continue;let q=r[h+Math.abs(E)-1];E<0&&(q=q.negate()),i=i.add(q)}return i},getPrecomputes(e,r,o){let i=Rt.get(r);return i||(i=this.precomputeWindow(r,e),e!==1&&Rt.set(r,o(i))),i},wNAFCached(e,r,o){const i=_t(e);return this.wNAF(i,this.getPrecomputes(i,e,o),r)},wNAFCachedUnsafe(e,r,o,i){const c=_t(e);return c===1?this.unsafeLadder(e,r,i):this.wNAFUnsafe(c,this.getPrecomputes(c,e,o),r,i)},setWindowSize(e,r){ue(r,n),ae.set(e,r),Rt.delete(e)}}}function $e(t,n,e,r){if(Ye(e,t),Ke(r,n),e.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=t.ZERO,i=Ft(BigInt(e.length)),c=i>12?i-3:i>4?i-2:i?2:1,u=(1<<c)-1,s=new Array(u+1).fill(o),f=Math.floor((n.BITS-1)/c)*c;let v=o;for(let d=f;d>=0;d-=c){s.fill(o);for(let E=0;E<r.length;E++){const q=r[E],p=Number(q>>BigInt(d)&BigInt(u));s[p]=s[p].add(e[E])}let h=o;for(let E=s.length-1,q=o;E>0;E--)q=q.add(s[E]),h=h.add(q);if(v=v.add(h),d!==0)for(let E=0;E<c;E++)v=v.double()}return v}function fe(t){return oe(t.Fp),pt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ie(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Qt(t){t.lowS!==void 0&&lt("lowS",t.lowS),t.prehash!==void 0&&lt("prehash",t.prehash)}function Ge(t){const n=fe(t);pt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:We,hexToBytes:Pe}=Ee;class Xe extends Error{constructor(n=""){super(n)}}const P={Err:Xe,_tlv:{encode:(t,n)=>{const{Err:e}=P;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,o=ft(r);if(o.length/2&128)throw new e("tlv.encode: long form length too big");const i=r>127?ft(o.length/2|128):"";return ft(t)+i+o+n},decode(t,n){const{Err:e}=P;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const o=n[r++],i=!!(o&128);let c=0;if(!i)c=o;else{const s=o&127;if(!s)throw new e("tlv.decode(long): indefinite length not supported");if(s>4)throw new e("tlv.decode(long): byte length is too big");const f=n.subarray(r,r+s);if(f.length!==s)throw new e("tlv.decode: length bytes not complete");if(f[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const v of f)c=c<<8|v;if(r+=s,c<128)throw new e("tlv.decode(long): not minimal encoding")}const u=n.subarray(r,r+c);if(u.length!==c)throw new e("tlv.decode: wrong value length");return{v:u,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=P;if(t<D)throw new n("integer: negative integers are not allowed");let e=ft(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=P;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return We(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=P,o=typeof t=="string"?Pe(t):t;bt(o);const{v:i,l:c}=r.decode(48,o);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:u,l:s}=r.decode(2,i),{v:f,l:v}=r.decode(2,s);if(v.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(u),s:e.decode(f)}},hexFromSig(t){const{_tlv:n,_int:e}=P,r=n.encode(2,e.encode(t.r)),o=n.encode(2,e.encode(t.s)),i=r+o;return n.encode(48,i)}},D=BigInt(0),H=BigInt(1),F=BigInt(2),vt=BigInt(3),Jt=BigInt(4);function Qe(t){const n=Ge(t),{Fp:e}=n,r=Me(n.n,n.nBitLength),o=n.toBytes||((p,a,l)=>{const g=a.toAffine();return yt(Uint8Array.from([4]),e.toBytes(g.x),e.toBytes(g.y))}),i=n.fromBytes||(p=>{const a=p.subarray(1),l=e.fromBytes(a.subarray(0,e.BYTES)),g=e.fromBytes(a.subarray(e.BYTES,2*e.BYTES));return{x:l,y:g}});function c(p){const{a,b:l}=n,g=e.sqr(p),b=e.mul(g,p);return e.add(e.add(b,e.mul(p,a)),l)}if(!e.eql(e.sqr(n.Gy),c(n.Gx)))throw new Error("bad generator point: equation left != right");function u(p){return At(p,H,n.n)}function s(p){const{allowedPrivateKeyLengths:a,nByteLength:l,wrapPrivateKey:g,n:b}=n;if(a&&typeof p!="bigint"){if(it(p)&&(p=dt(p)),typeof p!="string"||!a.includes(p.length))throw new Error("invalid private key");p=p.padStart(l*2,"0")}let B;try{B=typeof p=="bigint"?p:rt(K("private key",p,l))}catch{throw new Error("invalid private key, expected hex or "+l+" bytes, got "+typeof p)}return g&&(B=j(B,b)),ot("private key",B,H,b),B}function f(p){if(!(p instanceof h))throw new Error("ProjectivePoint expected")}const v=Vt((p,a)=>{const{px:l,py:g,pz:b}=p;if(e.eql(b,e.ONE))return{x:l,y:g};const B=p.is0();a==null&&(a=B?e.ONE:e.inv(b));const N=e.mul(l,a),O=e.mul(g,a),x=e.mul(b,a);if(B)return{x:e.ZERO,y:e.ZERO};if(!e.eql(x,e.ONE))throw new Error("invZ was invalid");return{x:N,y:O}}),d=Vt(p=>{if(p.is0()){if(n.allowInfinityPoint&&!e.is0(p.py))return;throw new Error("bad point: ZERO")}const{x:a,y:l}=p.toAffine();if(!e.isValid(a)||!e.isValid(l))throw new Error("bad point: x or y not FE");const g=e.sqr(l),b=c(a);if(!e.eql(g,b))throw new Error("bad point: equation left != right");if(!p.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(a,l,g){if(this.px=a,this.py=l,this.pz=g,a==null||!e.isValid(a))throw new Error("x required");if(l==null||!e.isValid(l))throw new Error("y required");if(g==null||!e.isValid(g))throw new Error("z required");Object.freeze(this)}static fromAffine(a){const{x:l,y:g}=a||{};if(!a||!e.isValid(l)||!e.isValid(g))throw new Error("invalid affine point");if(a instanceof h)throw new Error("projective point not allowed");const b=B=>e.eql(B,e.ZERO);return b(l)&&b(g)?h.ZERO:new h(l,g,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const l=e.invertBatch(a.map(g=>g.pz));return a.map((g,b)=>g.toAffine(l[b])).map(h.fromAffine)}static fromHex(a){const l=h.fromAffine(i(K("pointHex",a)));return l.assertValidity(),l}static fromPrivateKey(a){return h.BASE.multiply(s(a))}static msm(a,l){return $e(h,r,a,l)}_setWindowSize(a){q.setWindowSize(this,a)}assertValidity(){d(this)}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){f(a);const{px:l,py:g,pz:b}=this,{px:B,py:N,pz:O}=a,x=e.eql(e.mul(l,O),e.mul(B,b)),A=e.eql(e.mul(g,O),e.mul(N,b));return x&&A}negate(){return new h(this.px,e.neg(this.py),this.pz)}double(){const{a,b:l}=n,g=e.mul(l,vt),{px:b,py:B,pz:N}=this;let O=e.ZERO,x=e.ZERO,A=e.ZERO,S=e.mul(b,b),z=e.mul(B,B),T=e.mul(N,N),U=e.mul(b,B);return U=e.add(U,U),A=e.mul(b,N),A=e.add(A,A),O=e.mul(a,A),x=e.mul(g,T),x=e.add(O,x),O=e.sub(z,x),x=e.add(z,x),x=e.mul(O,x),O=e.mul(U,O),A=e.mul(g,A),T=e.mul(a,T),U=e.sub(S,T),U=e.mul(a,U),U=e.add(U,A),A=e.add(S,S),S=e.add(A,S),S=e.add(S,T),S=e.mul(S,U),x=e.add(x,S),T=e.mul(B,N),T=e.add(T,T),S=e.mul(T,U),O=e.sub(O,S),A=e.mul(T,z),A=e.add(A,A),A=e.add(A,A),new h(O,x,A)}add(a){f(a);const{px:l,py:g,pz:b}=this,{px:B,py:N,pz:O}=a;let x=e.ZERO,A=e.ZERO,S=e.ZERO;const z=n.a,T=e.mul(n.b,vt);let U=e.mul(l,B),M=e.mul(g,N),w=e.mul(b,O),m=e.add(l,g),y=e.add(B,N);m=e.mul(m,y),y=e.add(U,M),m=e.sub(m,y),y=e.add(l,b);let I=e.add(B,O);return y=e.mul(y,I),I=e.add(U,w),y=e.sub(y,I),I=e.add(g,b),x=e.add(N,O),I=e.mul(I,x),x=e.add(M,w),I=e.sub(I,x),S=e.mul(z,y),x=e.mul(T,w),S=e.add(x,S),x=e.sub(M,S),S=e.add(M,S),A=e.mul(x,S),M=e.add(U,U),M=e.add(M,U),w=e.mul(z,w),y=e.mul(T,y),M=e.add(M,w),w=e.sub(U,w),w=e.mul(z,w),y=e.add(y,w),U=e.mul(M,y),A=e.add(A,U),U=e.mul(I,y),x=e.mul(m,x),x=e.sub(x,U),U=e.mul(m,M),S=e.mul(I,S),S=e.add(S,U),new h(x,A,S)}subtract(a){return this.add(a.negate())}is0(){return this.equals(h.ZERO)}wNAF(a){return q.wNAFCached(this,a,h.normalizeZ)}multiplyUnsafe(a){const{endo:l,n:g}=n;ot("scalar",a,D,g);const b=h.ZERO;if(a===D)return b;if(this.is0()||a===H)return this;if(!l||q.hasPrecomputes(this))return q.wNAFCachedUnsafe(this,a,h.normalizeZ);let{k1neg:B,k1:N,k2neg:O,k2:x}=l.splitScalar(a),A=b,S=b,z=this;for(;N>D||x>D;)N&H&&(A=A.add(z)),x&H&&(S=S.add(z)),z=z.double(),N>>=H,x>>=H;return B&&(A=A.negate()),O&&(S=S.negate()),S=new h(e.mul(S.px,l.beta),S.py,S.pz),A.add(S)}multiply(a){const{endo:l,n:g}=n;ot("scalar",a,H,g);let b,B;if(l){const{k1neg:N,k1:O,k2neg:x,k2:A}=l.splitScalar(a);let{p:S,f:z}=this.wNAF(O),{p:T,f:U}=this.wNAF(A);S=q.constTimeNegate(N,S),T=q.constTimeNegate(x,T),T=new h(e.mul(T.px,l.beta),T.py,T.pz),b=S.add(T),B=z.add(U)}else{const{p:N,f:O}=this.wNAF(a);b=N,B=O}return h.normalizeZ([b,B])[0]}multiplyAndAddUnsafe(a,l,g){const b=h.BASE,B=(O,x)=>x===D||x===H||!O.equals(b)?O.multiplyUnsafe(x):O.multiply(x),N=B(this,l).add(B(a,g));return N.is0()?void 0:N}toAffine(a){return v(this,a)}isTorsionFree(){const{h:a,isTorsionFree:l}=n;if(a===H)return!0;if(l)return l(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:l}=n;return a===H?this:l?l(h,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return lt("isCompressed",a),this.assertValidity(),o(h,this,a)}toHex(a=!0){return lt("isCompressed",a),dt(this.toRawBytes(a))}}h.BASE=new h(n.Gx,n.Gy,e.ONE),h.ZERO=new h(e.ZERO,e.ONE,e.ZERO);const E=n.nBitLength,q=De(h,n.endo?Math.ceil(E/2):E);return{CURVE:n,ProjectivePoint:h,normPrivateKeyToScalar:s,weierstrassEquation:c,isWithinCurveOrder:u}}function Je(t){const n=fe(t);return pt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Fe(t){const n=Je(t),{Fp:e,n:r}=n,o=e.BYTES+1,i=2*e.BYTES+1;function c(w){return j(w,r)}function u(w){return Ct(w,r)}const{ProjectivePoint:s,normPrivateKeyToScalar:f,weierstrassEquation:v,isWithinCurveOrder:d}=Qe({...n,toBytes(w,m,y){const I=m.toAffine(),L=e.toBytes(I.x),_=yt;return lt("isCompressed",y),y?_(Uint8Array.from([m.hasEvenY()?2:3]),L):_(Uint8Array.from([4]),L,e.toBytes(I.y))},fromBytes(w){const m=w.length,y=w[0],I=w.subarray(1);if(m===o&&(y===2||y===3)){const L=rt(I);if(!At(L,H,e.ORDER))throw new Error("Point is not on curve");const _=v(L);let Z;try{Z=e.sqrt(_)}catch(Y){const k=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+k)}const C=(Z&H)===H;return(y&1)===1!==C&&(Z=e.neg(Z)),{x:L,y:Z}}else if(m===i&&y===4){const L=e.fromBytes(I.subarray(0,e.BYTES)),_=e.fromBytes(I.subarray(e.BYTES,2*e.BYTES));return{x:L,y:_}}else{const L=o,_=i;throw new Error("invalid Point, expected length of "+L+", or uncompressed "+_+", got "+m)}}}),h=w=>dt(wt(w,n.nByteLength));function E(w){const m=r>>H;return w>m}function q(w){return E(w)?c(-w):w}const p=(w,m,y)=>rt(w.slice(m,y));class a{constructor(m,y,I){this.r=m,this.s=y,this.recovery=I,this.assertValidity()}static fromCompact(m){const y=n.nByteLength;return m=K("compactSignature",m,y*2),new a(p(m,0,y),p(m,y,2*y))}static fromDER(m){const{r:y,s:I}=P.toSig(K("DER",m));return new a(y,I)}assertValidity(){ot("r",this.r,H,r),ot("s",this.s,H,r)}addRecoveryBit(m){return new a(this.r,this.s,m)}recoverPublicKey(m){const{r:y,s:I,recovery:L}=this,_=O(K("msgHash",m));if(L==null||![0,1,2,3].includes(L))throw new Error("recovery id invalid");const Z=L===2||L===3?y+n.n:y;if(Z>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const C=L&1?"03":"02",G=s.fromHex(C+h(Z)),Y=u(Z),k=c(-_*Y),st=c(I*Y),X=s.BASE.multiplyAndAddUnsafe(G,k,st);if(!X)throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return E(this.s)}normalizeS(){return this.hasHighS()?new a(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return P.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}const l={isValidPrivateKey(w){try{return f(w),!0}catch{return!1}},normPrivateKeyToScalar:f,randomPrivateKey:()=>{const w=ce(n.n);return je(n.randomBytes(w),n.n)},precompute(w=8,m=s.BASE){return m._setWindowSize(w),m.multiply(BigInt(3)),m}};function g(w,m=!0){return s.fromPrivateKey(w).toRawBytes(m)}function b(w){const m=it(w),y=typeof w=="string",I=(m||y)&&w.length;return m?I===o||I===i:y?I===2*o||I===2*i:w instanceof s}function B(w,m,y=!0){if(b(w))throw new Error("first arg must be private key");if(!b(m))throw new Error("second arg must be public key");return s.fromHex(m).multiply(f(w)).toRawBytes(y)}const N=n.bits2int||function(w){if(w.length>8192)throw new Error("input is too large");const m=rt(w),y=w.length*8-n.nBitLength;return y>0?m>>BigInt(y):m},O=n.bits2int_modN||function(w){return c(N(w))},x=jt(n.nBitLength);function A(w){return ot("num < 2^"+n.nBitLength,w,D,x),wt(w,n.nByteLength)}function S(w,m,y=z){if(["recovered","canonical"].some(tt=>tt in y))throw new Error("sign() legacy options not supported");const{hash:I,randomBytes:L}=n;let{lowS:_,prehash:Z,extraEntropy:C}=y;_==null&&(_=!0),w=K("msgHash",w),Qt(y),Z&&(w=K("prehashed msgHash",I(w)));const G=O(w),Y=f(m),k=[A(Y),A(G)];if(C!=null&&C!==!1){const tt=C===!0?L(e.BYTES):C;k.push(K("extraEntropy",tt))}const st=yt(...k),X=G;function Ot(tt){const ct=N(tt);if(!d(ct))return;const It=u(ct),gt=s.BASE.multiply(ct).toAffine(),et=c(gt.x);if(et===D)return;const mt=c(It*c(X+et*Y));if(mt===D)return;let ut=(gt.x===et?0:2)|Number(gt.y&H),Kt=mt;return _&&E(mt)&&(Kt=q(mt),ut^=1),new a(et,Kt,ut)}return{seed:st,k2sig:Ot}}const z={lowS:n.lowS,prehash:!1},T={lowS:n.lowS,prehash:!1};function U(w,m,y=z){const{seed:I,k2sig:L}=S(w,m,y),_=n;return te(_.hash.outputLen,_.nByteLength,_.hmac)(I,L)}s.BASE._setWindowSize(8);function M(w,m,y,I=T){const L=w;m=K("msgHash",m),y=K("publicKey",y);const{lowS:_,prehash:Z,format:C}=I;if(Qt(I),"strict"in I)throw new Error("options.strict was renamed to lowS");if(C!==void 0&&C!=="compact"&&C!=="der")throw new Error("format must be compact or der");const G=typeof L=="string"||it(L),Y=!G&&!C&&typeof L=="object"&&L!==null&&typeof L.r=="bigint"&&typeof L.s=="bigint";if(!G&&!Y)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let k,st;try{if(Y&&(k=new a(L.r,L.s)),G){try{C!=="compact"&&(k=a.fromDER(L))}catch(ut){if(!(ut instanceof P.Err))throw ut}!k&&C!=="der"&&(k=a.fromCompact(L))}st=s.fromHex(y)}catch{return!1}if(!k||_&&k.hasHighS())return!1;Z&&(m=n.hash(m));const{r:X,s:Ot}=k,tt=O(m),ct=u(Ot),It=c(tt*ct),gt=c(X*ct),et=s.BASE.multiplyAndAddUnsafe(st,It,gt)?.toAffine();return et?c(et.x)===X:!1}return{CURVE:n,getPublicKey:g,getSharedSecret:B,sign:U,verify:M,ProjectivePoint:s,Signature:a,utils:l}}function tn(t,n){const e=t.ORDER;let r=D;for(let q=e-H;q%F===D;q/=F)r+=H;const o=r,i=F<<o-H-H,c=i*F,u=(e-H)/c,s=(u-H)/F,f=c-H,v=i,d=t.pow(n,u),h=t.pow(n,(u+H)/F);let E=(q,p)=>{let a=d,l=t.pow(p,f),g=t.sqr(l);g=t.mul(g,p);let b=t.mul(q,g);b=t.pow(b,s),b=t.mul(b,l),l=t.mul(b,p),g=t.mul(b,q);let B=t.mul(g,l);b=t.pow(B,v);let N=t.eql(b,t.ONE);l=t.mul(g,h),b=t.mul(B,a),g=t.cmov(l,g,N),B=t.cmov(b,B,N);for(let O=o;O>H;O--){let x=O-F;x=F<<x-H;let A=t.pow(B,x);const S=t.eql(A,t.ONE);l=t.mul(g,a),a=t.mul(a,a),A=t.mul(B,a),g=t.cmov(l,g,S),B=t.cmov(A,B,S)}return{isValid:N,value:g}};if(t.ORDER%Jt===vt){const q=(t.ORDER-vt)/Jt,p=t.sqrt(t.neg(n));E=(a,l)=>{let g=t.sqr(l);const b=t.mul(a,l);g=t.mul(g,b);let B=t.pow(g,q);B=t.mul(B,b);const N=t.mul(B,p),O=t.mul(t.sqr(B),l),x=t.eql(O,a);let A=t.cmov(N,B,x);return{isValid:x,value:A}}}return E}function on(t,n){if(oe(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=tn(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,i,c,u,s,f,v,d;o=t.sqr(r),o=t.mul(o,n.Z),i=t.sqr(o),i=t.add(i,o),c=t.add(i,t.ONE),c=t.mul(c,n.B),u=t.cmov(n.Z,t.neg(i),!t.eql(i,t.ZERO)),u=t.mul(u,n.A),i=t.sqr(c),f=t.sqr(u),s=t.mul(f,n.A),i=t.add(i,s),i=t.mul(i,c),f=t.mul(f,u),s=t.mul(f,n.B),i=t.add(i,s),v=t.mul(o,c);const{isValid:h,value:E}=e(i,f);d=t.mul(o,r),d=t.mul(d,E),v=t.cmov(v,c,h),d=t.cmov(d,E,h);const q=t.isOdd(r)===t.isOdd(d);return d=t.cmov(t.neg(d),d,q),v=t.div(v,u),{x:v,y:d}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function en(t){return{hash:t,hmac:(n,...e)=>re(t,n,Ae(...e)),randomBytes:Oe}}function sn(t,n){const e=r=>Fe({...t,...en(r)});return{...e(n),create:e}}export{Me as F,bt as a,rt as b,sn as c,yt as d,ot as e,K as f,on as g,At as i,j as m,wt as n,rn as p,Oe as r,nn as s,ge as u,pt as v};
