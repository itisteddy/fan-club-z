{"version":3,"file":"useMerkleClaim-2ef83797.js","sources":["../../src/chain/escrowMerkleAbi.ts","../../src/hooks/useMerkleClaim.ts"],"sourcesContent":["// Minimal ABI for Merkle-based settlement\nexport const ESCROW_MERKLE_ABI = [\n  {\n    type: 'function',\n    name: 'postSettlementRoot',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { name: 'predictionId', type: 'bytes32' },\n      { name: 'root', type: 'bytes32' },\n      { name: 'creator', type: 'address' },\n      { name: 'creatorFee', type: 'uint256' },\n      { name: 'platform', type: 'address' },\n      { name: 'platformFee', type: 'uint256' },\n    ],\n    outputs: [],\n  },\n  {\n    type: 'function',\n    name: 'claim',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { name: 'predictionId', type: 'bytes32' },\n      { name: 'amount', type: 'uint256' },\n      { name: 'proof', type: 'bytes32[]' },\n    ],\n    outputs: [],\n  },\n] as const;\n\n\n","import { useCallback, useState } from 'react';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { BaseError, type Hash } from 'viem';\nimport { useAccount, usePublicClient, useSwitchChain, useWriteContract } from 'wagmi';\nimport { baseSepolia } from 'wagmi/chains';\nimport { waitForTransactionReceipt } from 'viem/actions';\nimport toast from 'react-hot-toast';\nimport { ESCROW_MERKLE_ABI } from '@/chain/escrowMerkleAbi';\nimport { useWalletConnectSession } from '@/hooks/useWalletConnectSession';\nimport { useAuthStore } from '@/store/authStore';\nimport { invalidateAfterClaim } from '@/utils/queryInvalidation';\nimport { \n  logTransaction, \n  parseOnchainError, \n  isSessionError,\n  cleanupWalletConnectStorage,\n  broadcastReconnectRequired,\n  broadcastBalanceRefresh,\n  isUserRejection,\n  ensureWalletReady,\n} from '@/services/onchainTransactionService';\nimport { useWeb3Recovery } from '@/providers/Web3Provider';\nimport { getApiUrl } from '@/utils/environment';\n\nfunction toBytes32FromUuid(uuid: string): `0x${string}` {\n  const hex = uuid.replace(/-/g, '').toLowerCase().padEnd(64, '0');\n  return `0x${hex}` as const;\n}\n\n// Convert USDC units to USD\nfunction usdcUnitsToUSD(units: bigint): number {\n  return Number(units) / 1_000_000;\n}\n\nexport function useMerkleClaim() {\n  const { address, chainId, isConnected } = useAccount();\n  const publicClient = usePublicClient();\n  const { switchChainAsync } = useSwitchChain();\n  const { writeContractAsync } = useWriteContract();\n  const { withSessionRecovery, recoverFromError, cleanupWalletConnectSessions } = useWalletConnectSession();\n  const queryClient = useQueryClient();\n  const { sessionHealthy } = useWeb3Recovery();\n\n  const [isClaiming, setIsClaiming] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  /**\n   * Handle session errors with recovery\n   */\n  async function handleSessionErrorRecovery(err: unknown): Promise<boolean> {\n    if (!isSessionError(err)) {\n      return false;\n    }\n    \n    console.log('[FCZ-CLAIM] Detected stale WalletConnect session, attempting recovery...');\n    \n    try {\n      cleanupWalletConnectStorage();\n      await recoverFromError({ attemptReconnect: true });\n      toast.error('Wallet session expired. Please reconnect and try again.', { id: 'session-error' });\n      broadcastReconnectRequired('Wallet session expired');\n      return true;\n    } catch (recoveryErr) {\n      console.error('[FCZ-CLAIM] Session recovery failed:', recoveryErr);\n      cleanupWalletConnectStorage();\n      await cleanupWalletConnectSessions();\n      toast.error('Wallet connection lost. Please reconnect.', { id: 'session-error' });\n      return true;\n    }\n  }\n\n  const claim = useCallback(\n    async (args: {\n      predictionId: string;\n      escrowAddress?: `0x${string}`;\n      amountUnits: bigint;\n      proof: `0x${string}`[];\n    }): Promise<`0x${string}` | null> => {\n      setIsClaiming(true);\n      setError(null);\n\n      if (!address || !isConnected) {\n        toast.error('Connect your wallet to claim.');\n        setIsClaiming(false);\n        return null;\n      }\n\n      try {\n        ensureWalletReady({\n          address,\n          chainId,\n          expectedChainId: baseSepolia.id,\n          isConnected,\n          sessionHealthy,\n        });\n      } catch (err) {\n        const parsed = parseOnchainError(err);\n        toast.error(parsed.message, { id: 'claim' });\n        setError(parsed.message);\n        setIsClaiming(false);\n        return null;\n      }\n      \n      let txHash: Hash | null = null;\n      const amountUSD = usdcUnitsToUSD(args.amountUnits);\n      const userId = useAuthStore.getState().user?.id || '';\n      \n      try {\n        if (!isConnected || !address) {\n          toast.error('Connect wallet to claim');\n          return null;\n        }\n        if (chainId !== baseSepolia.id) {\n          await switchChainAsync({ chainId: baseSepolia.id });\n        }\n\n        const escrowAddress =\n          args.escrowAddress ||\n          (import.meta.env.VITE_BASE_ESCROW_ADDRESS as `0x${string}`) ||\n          (import.meta.env.VITE_ESCROW_CONTRACT_ADDRESS as `0x${string}`);\n        if (!escrowAddress) {\n          throw new Error('Escrow contract address missing (VITE_BASE_ESCROW_ADDRESS)');\n        }\n\n        const predictionIdHex = toBytes32FromUuid(args.predictionId);\n\n        console.log('[FCZ-CLAIM] Submitting claim:', {\n          predictionId: args.predictionId,\n          amount: amountUSD,\n          proofLength: args.proof.length,\n        });\n\n        toast.loading('Submitting claim...', { id: 'claim' });\n        \n        // Execute with session recovery wrapper\n        try {\n          txHash = await withSessionRecovery(async () => {\n            return await writeContractAsync({\n              address: escrowAddress,\n              abi: ESCROW_MERKLE_ABI,\n              functionName: 'claim',\n              args: [predictionIdHex, args.amountUnits, args.proof],\n            } as any);\n          }, { maxRetries: 1, showToast: false, operationTimeoutMs: 20000 }) as Hash;\n        } catch (writeErr) {\n          // Check for user rejection first\n          if (isUserRejection(writeErr)) {\n            toast.dismiss('claim');\n            throw new Error('Transaction cancelled by user');\n          }\n          \n          // Check for session errors\n          const wasSessionError = await handleSessionErrorRecovery(writeErr);\n          if (wasSessionError) {\n            throw new Error('Wallet session expired. Please reconnect and try again.');\n          }\n          \n          throw writeErr;\n        }\n\n        if (!txHash) {\n          throw new Error('Missing transaction hash after claim submission');\n        }\n\n        console.log('[FCZ-CLAIM] Claim tx sent:', txHash);\n\n        // Log claim as pending\n        if (userId) {\n          await logTransaction({\n            userId,\n            walletAddress: address,\n            txHash,\n            type: 'claim',\n            status: 'pending',\n            amount: amountUSD,\n            predictionId: args.predictionId,\n          }).catch(e => console.warn('[FCZ-CLAIM] Log failed:', e));\n        }\n\n        // Persist tx hash for later reference\n        try {\n          const key = `fcz:lastTx:claim:${args.predictionId}:${address.toLowerCase()}`;\n          localStorage.setItem(key, txHash);\n          window.dispatchEvent(new CustomEvent('fcz:tx', { \n            detail: { kind: 'claim', txHash, predictionId: args.predictionId } \n          }));\n        } catch {}\n\n        toast.loading('Waiting for confirmation...', { id: 'claim' });\n\n        // Wait for receipt\n        let receiptSuccess = true;\n        if (publicClient) {\n          try {\n            const receipt = await waitForTransactionReceipt(publicClient as any, { \n              hash: txHash,\n              confirmations: 1,\n              timeout: 180_000,\n            });\n            \n            if (receipt.status === 'reverted') {\n              receiptSuccess = false;\n              toast.error('Claim reverted — settlement root not posted yet or invalid proof', { id: 'claim' });\n            }\n          } catch (receiptErr) {\n            console.warn('[FCZ-CLAIM] Receipt wait failed:', receiptErr);\n          }\n        }\n\n        // If receipt failed, return early\n        if (!receiptSuccess) {\n          // Log claim as failed\n          if (userId) {\n            await logTransaction({\n              userId,\n              walletAddress: address,\n              txHash,\n              type: 'claim',\n              status: 'failed',\n              amount: amountUSD,\n              predictionId: args.predictionId,\n              error: 'Transaction reverted on-chain',\n            }).catch(e => console.warn('[FCZ-CLAIM] Log failed:', e));\n          }\n          return txHash as `0x${string}`;\n        }\n\n        console.log('[FCZ-CLAIM] ✓ Claim confirmed:', txHash);\n\n        // Log claim as completed\n        if (userId) {\n          await logTransaction({\n            userId,\n            walletAddress: address,\n            txHash,\n            type: 'claim',\n            status: 'completed',\n            amount: amountUSD,\n            predictionId: args.predictionId,\n          }).catch(e => console.warn('[FCZ-CLAIM] Log failed:', e));\n        }\n\n        // Inspect receipt logs for Transfer to user\n        try {\n          if (publicClient && address) {\n            const receipt = await (publicClient as any).getTransactionReceipt({ hash: txHash });\n            const TRANSFER_TOPIC = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';\n            const userTopic = `0x000000000000000000000000${address.toLowerCase().slice(2)}`;\n            const hasTransferToUser = (receipt?.logs || []).some((log: any) => \n              Array.isArray(log.topics) && \n              log.topics.length >= 3 && \n              log.topics[0] === TRANSFER_TOPIC && \n              log.topics[2]?.toLowerCase() === userTopic\n            );\n            \n            const short = `${txHash.slice(0, 8)}…${txHash.slice(-6)}`;\n            if (!hasTransferToUser) {\n              toast('Claim mined, but no ERC20 transfer detected. View tx: ' + short, { id: 'claim' });\n            } else {\n              toast.success('Claim successful! Tx: ' + short, { id: 'claim' });\n            }\n          } else {\n            const short = `${txHash.slice(0, 8)}…${txHash.slice(-6)}`;\n            toast.success('Claim successful! Tx: ' + short, { id: 'claim' });\n          }\n        } catch {\n          const short = `${txHash.slice(0, 8)}…${txHash.slice(-6)}`;\n          toast.success('Claim successful! Tx: ' + short, { id: 'claim' });\n        }\n        \n        // Mark as claimed locally\n        try {\n          const addrLower = address.toLowerCase();\n          localStorage.setItem(`fcz:claimed:${args.predictionId}:${addrLower}`, '1');\n        } catch {}\n\n        // PERFORMANCE FIX: Reconcile wallet balance with backend (non-blocking)\n        // Don't await - let it happen in background\n        if (userId && address) {\n          const apiBase = getApiUrl();\n          fetch(`${apiBase}/api/wallet/reconcile`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              userId,\n              walletAddress: address,\n              txHash,\n            }),\n          })\n            .then(() => {\n              console.log('[FCZ-CLAIM] Wallet reconciled with backend');\n            })\n            .catch((reconcileError) => {\n              console.warn('[FCZ-CLAIM] Reconcile after claim failed:', reconcileError);\n            });\n        }\n        \n        // PERFORMANCE FIX: Invalidate queries (non-blocking, debounced)\n        invalidateAfterClaim(queryClient, {\n          userId,\n          predictionId: args.predictionId,\n        });\n        \n        // PERFORMANCE FIX: Trigger global balance refresh (debounced)\n        // This is now debounced in setupBalanceRefreshListener\n        broadcastBalanceRefresh();\n        \n        return txHash as `0x${string}`;\n      } catch (e: any) {\n        console.error('[FCZ-CLAIM] Claim failed:', e);\n        \n        // Check for session errors\n        const wasSessionError = await handleSessionErrorRecovery(e);\n        \n        let msg = e?.shortMessage || e?.message || 'Claim failed';\n        let markAsClaimed = false;\n        \n        if (e instanceof BaseError) {\n          const lower = (e.shortMessage || '').toLowerCase();\n          if (lower.includes('insufficient')) msg = 'Insufficient funds to pay gas';\n          if (lower.includes('user rejected')) msg = 'User rejected the transaction';\n          if (lower.includes('already claimed') || lower.includes('duplicate')) {\n            msg = 'Already claimed';\n            markAsClaimed = true;\n          }\n          if (lower.includes('execution reverted')) {\n            msg = 'Claim reverted — already claimed or invalid proof';\n          }\n        }\n        \n        // Parse error for better message\n        const parsed = parseOnchainError(e);\n        if (parsed.code !== 'UNKNOWN_ERROR') {\n          msg = parsed.message;\n        }\n        \n        // Log failure if we had a tx hash\n        if (txHash && userId && !wasSessionError && !markAsClaimed) {\n          await logTransaction({\n            userId,\n            walletAddress: address!,\n            txHash,\n            type: 'claim',\n            status: 'failed',\n            amount: amountUSD,\n            predictionId: args.predictionId,\n            error: msg,\n          }).catch(err => console.warn('[FCZ-CLAIM] Log failed:', err));\n        }\n        \n        if (markAsClaimed) {\n          try {\n            const addrLower = address?.toLowerCase() || '';\n            if (addrLower) {\n              localStorage.setItem(`fcz:claimed:${args.predictionId}:${addrLower}`, '1');\n            }\n          } catch {}\n          invalidateAfterClaim(queryClient, {\n            userId,\n            predictionId: args.predictionId,\n          });\n          toast.success('Already claimed', { id: 'claim' });\n          return null;\n        } else if (!wasSessionError) {\n          setError(msg);\n          toast.error(msg, { id: 'claim' });\n          return null;\n        } else {\n          return null;\n        }\n      } finally {\n        setIsClaiming(false);\n      }\n    },\n    [address, chainId, isConnected, publicClient, switchChainAsync, writeContractAsync, queryClient, withSessionRecovery, recoverFromError, cleanupWalletConnectSessions, sessionHealthy]\n  );\n\n  return {\n    isClaiming,\n    error,\n    claim,\n  };\n}\n\nexport default useMerkleClaim;\n"],"names":["ESCROW_MERKLE_ABI","toBytes32FromUuid","uuid","usdcUnitsToUSD","units","useMerkleClaim","address","chainId","isConnected","useAccount","publicClient","usePublicClient","switchChainAsync","useSwitchChain","writeContractAsync","useWriteContract","withSessionRecovery","recoverFromError","cleanupWalletConnectSessions","useWalletConnectSession","queryClient","useQueryClient","sessionHealthy","useWeb3Recovery","isClaiming","setIsClaiming","useState","error","setError","handleSessionErrorRecovery","err","isSessionError","cleanupWalletConnectStorage","toast","broadcastReconnectRequired","claim","useCallback","args","ensureWalletReady","baseSepolia","parsed","parseOnchainError","txHash","amountUSD","userId","useAuthStore","escrowAddress","predictionIdHex","writeErr","isUserRejection","logTransaction","key","receiptSuccess","waitForTransactionReceipt","receipt","TRANSFER_TOPIC","userTopic","hasTransferToUser","log","short","addrLower","apiBase","getApiUrl","reconcileError","invalidateAfterClaim","broadcastBalanceRefresh","e","wasSessionError","msg","markAsClaimed","BaseError","lower"],"mappings":"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"}