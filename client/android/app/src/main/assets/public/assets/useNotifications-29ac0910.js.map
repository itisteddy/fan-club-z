{"version":3,"file":"useNotifications-29ac0910.js","sources":["../../src/hooks/useNotifications.ts"],"sourcesContent":["import { useState, useCallback, useEffect, useRef } from 'react';\nimport { useAuthSession } from '../providers/AuthSessionProvider';\nimport { supabase } from '../lib/supabase';\nimport { getApiUrl } from '../utils/environment';\nimport { useMaintenanceStore } from '../store/maintenanceStore';\n\nexport interface Notification {\n  id: string;\n  type: string;\n  title: string;\n  body: string | null;\n  href: string | null;\n  metadata: Record<string, any>;\n  readAt: string | null;\n  createdAt: string;\n}\n\nexport interface NotificationsResponse {\n  items: Notification[];\n  unreadCount: number;\n  nextCursor?: string;\n  version: string;\n}\n\ninterface UseNotificationsOptions {\n  limit?: number;\n  autoRefresh?: boolean;\n  refreshInterval?: number; // milliseconds\n}\n\n/**\n * Hook for fetching and managing in-app notifications\n */\nexport function useNotifications(options: UseNotificationsOptions = {}) {\n  const { session } = useAuthSession();\n  const { limit = 20, autoRefresh = true, refreshInterval = 30000 } = options;\n  const maintenanceActive = useMaintenanceStore((s) => s.active);\n\n  const [notifications, setNotifications] = useState<Notification[]>([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [nextCursor, setNextCursor] = useState<string | undefined>(undefined);\n  const [hasMore, setHasMore] = useState(false);\n\n  const refreshTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const isMountedRef = useRef(true);\n\n  useEffect(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n      if (refreshTimeoutRef.current) {\n        clearTimeout(refreshTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  /**\n   * Get auth token from Supabase session\n   */\n  const getAuthToken = useCallback(async (): Promise<string | null> => {\n    if (!session?.access_token) {\n      const { data: { session: currentSession } } = await supabase.auth.getSession();\n      return currentSession?.access_token || null;\n    }\n    return session.access_token;\n  }, [session]);\n\n  /**\n   * Fetch notifications from API\n   */\n  const fetchNotifications = useCallback(\n    async (cursor?: string, append = false) => {\n      if (!session) {\n        setError(new Error('Not authenticated'));\n        return;\n      }\n      if (maintenanceActive) {\n        // Avoid spamming API during maintenance (overlay will be shown globally)\n        return;\n      }\n\n      setLoading(true);\n      setError(null);\n\n      try {\n        const token = await getAuthToken();\n        if (!token) {\n          throw new Error('No auth token available');\n        }\n\n        const params = new URLSearchParams();\n        params.set('limit', String(limit));\n        if (cursor) {\n          params.set('cursor', cursor);\n        }\n\n        const apiUrl = getApiUrl();\n        const response = await fetch(`${apiUrl}/api/v2/notifications?${params.toString()}`, {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${token}`,\n          },\n          credentials: 'include',\n        });\n\n        if (!response.ok) {\n          const errData = await response.json().catch(() => ({}));\n          throw new Error(errData?.message || `HTTP error! status: ${response.status}`);\n        }\n\n        const data: NotificationsResponse = await response.json();\n\n        if (!isMountedRef.current) return;\n\n        if (append) {\n          setNotifications((prev) => [...prev, ...data.items]);\n        } else {\n          setNotifications(data.items);\n        }\n\n        setUnreadCount(data.unreadCount || 0);\n        setNextCursor(data.nextCursor);\n        setHasMore(Boolean(data.nextCursor));\n      } catch (err) {\n        if (!isMountedRef.current) return;\n        const error = err instanceof Error ? err : new Error('Failed to fetch notifications');\n        setError(error);\n        console.error('[useNotifications] Fetch error:', error);\n      } finally {\n        if (isMountedRef.current) {\n          setLoading(false);\n        }\n      }\n    },\n    [session, limit, getAuthToken]\n  );\n\n  /**\n   * Refresh unread count only (lightweight)\n   */\n  const refreshUnreadCount = useCallback(async () => {\n    if (!session) return;\n    if (maintenanceActive) return;\n\n    try {\n      const token = await getAuthToken();\n      if (!token) return;\n\n      const apiUrl = getApiUrl();\n      const response = await fetch(`${apiUrl}/api/v2/notifications?limit=1`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`,\n        },\n        credentials: 'include',\n      });\n\n      if (response.ok) {\n        const data: NotificationsResponse = await response.json();\n        if (isMountedRef.current) {\n          setUnreadCount(data.unreadCount || 0);\n        }\n      }\n    } catch (err) {\n      // Silently fail for unread count refresh\n      console.warn('[useNotifications] Failed to refresh unread count:', err);\n    }\n  }, [session, getAuthToken]);\n\n  /**\n   * Mark notifications as read\n   */\n  const markRead = useCallback(\n    async (ids: string[]) => {\n      if (!session || ids.length === 0) return;\n      if (maintenanceActive) return;\n\n      try {\n        const token = await getAuthToken();\n        if (!token) throw new Error('No auth token available');\n\n        const apiUrl = getApiUrl();\n        const response = await fetch(`${apiUrl}/api/v2/notifications/mark-read`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${token}`,\n          },\n          credentials: 'include',\n          body: JSON.stringify({ ids }),\n        });\n\n        if (!response.ok) {\n          const errData = await response.json().catch(() => ({}));\n          throw new Error(errData?.message || `HTTP error! status: ${response.status}`);\n        }\n\n        // Update local state optimistically\n        setNotifications((prev) =>\n          prev.map((n) => (ids.includes(n.id) ? { ...n, readAt: new Date().toISOString() } : n))\n        );\n        setUnreadCount((prev) => Math.max(0, prev - ids.length));\n\n        // Refresh to ensure sync\n        await refreshUnreadCount();\n      } catch (err) {\n        console.error('[useNotifications] Mark read error:', err);\n        throw err;\n      }\n    },\n    [session, getAuthToken, refreshUnreadCount]\n  );\n\n  /**\n   * Mark all notifications as read\n   */\n  const markAllRead = useCallback(async () => {\n    if (!session) return;\n    if (maintenanceActive) return;\n\n    try {\n      const token = await getAuthToken();\n      if (!token) throw new Error('No auth token available');\n\n      const apiUrl = getApiUrl();\n      const response = await fetch(`${apiUrl}/api/v2/notifications/mark-all-read`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`,\n        },\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        const errData = await response.json().catch(() => ({}));\n        throw new Error(errData?.message || `HTTP error! status: ${response.status}`);\n      }\n\n      // Update local state optimistically\n      setNotifications((prev) => prev.map((n) => ({ ...n, readAt: new Date().toISOString() })));\n      setUnreadCount(0);\n    } catch (err) {\n      console.error('[useNotifications] Mark all read error:', err);\n      throw err;\n    }\n  }, [session, getAuthToken]);\n\n  /**\n   * Load more notifications (pagination)\n   */\n  const loadMore = useCallback(() => {\n    if (hasMore && nextCursor && !loading) {\n      fetchNotifications(nextCursor, true);\n    }\n  }, [hasMore, nextCursor, loading, fetchNotifications]);\n\n  // Initial fetch\n  useEffect(() => {\n    if (session) {\n      fetchNotifications();\n    }\n  }, [session]); // Only fetch when session changes\n\n  // Auto-refresh unread count on window focus\n  useEffect(() => {\n    if (!autoRefresh || !session) return;\n\n    const handleFocus = () => {\n      refreshUnreadCount();\n    };\n\n    window.addEventListener('focus', handleFocus);\n    return () => window.removeEventListener('focus', handleFocus);\n  }, [autoRefresh, session, refreshUnreadCount]);\n\n  // Periodic refresh of unread count\n  useEffect(() => {\n    if (!autoRefresh || !session) return;\n\n    const scheduleRefresh = () => {\n      if (refreshTimeoutRef.current) {\n        clearTimeout(refreshTimeoutRef.current);\n      }\n      refreshTimeoutRef.current = setTimeout(() => {\n        if (isMountedRef.current) {\n          refreshUnreadCount();\n          scheduleRefresh(); // Schedule next refresh\n        }\n      }, refreshInterval);\n    };\n\n    scheduleRefresh();\n    return () => {\n      if (refreshTimeoutRef.current) {\n        clearTimeout(refreshTimeoutRef.current);\n      }\n    };\n  }, [autoRefresh, session, refreshInterval, refreshUnreadCount]);\n\n  /**\n   * Sync reminders (closing soon + claim reminders)\n   * Called on app start/focus\n   */\n  const syncReminders = useCallback(async () => {\n    if (!session) return;\n\n    try {\n      const token = await getAuthToken();\n      if (!token) return;\n\n      const apiUrl = getApiUrl();\n      const response = await fetch(`${apiUrl}/api/v2/notifications/reminders/sync`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`,\n        },\n        credentials: 'include',\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        // Refresh notifications to show new reminders\n        if (data.created > 0) {\n          await fetchNotifications();\n        }\n      }\n    } catch (err) {\n      // Silently fail for reminder sync\n      console.warn('[useNotifications] Failed to sync reminders:', err);\n    }\n  }, [session, getAuthToken, fetchNotifications]);\n\n  return {\n    notifications,\n    unreadCount,\n    loading,\n    error,\n    hasMore,\n    fetchNotifications: () => fetchNotifications(),\n    refreshUnreadCount,\n    markRead,\n    markAllRead,\n    loadMore,\n    syncReminders,\n  };\n}\n"],"names":["useNotifications","options","session","useAuthSession","limit","autoRefresh","refreshInterval","maintenanceActive","useMaintenanceStore","s","notifications","setNotifications","useState","unreadCount","setUnreadCount","loading","setLoading","error","setError","nextCursor","setNextCursor","hasMore","setHasMore","refreshTimeoutRef","useRef","isMountedRef","useEffect","getAuthToken","useCallback","currentSession","supabase","fetchNotifications","cursor","append","token","params","apiUrl","getApiUrl","response","errData","data","prev","err","refreshUnreadCount","markRead","ids","n","markAllRead","loadMore","handleFocus","scheduleRefresh","syncReminders"],"mappings":"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"}