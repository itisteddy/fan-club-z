import{v as re,a as A,u as G,m as w,b as V,d as _,F as oe,c as ce,s as T,n as Y,e as ae,f as E,r as se,i as j,p as l,g as ie}from"./_shortw_utils-2428d36e.js";const de=V;function x(t,e){if(S(t),S(e),t<0||t>=1<<8*e)throw new Error("invalid I2OSP input: "+t);const f=Array.from({length:e}).fill(0);for(let n=e-1;n>=0;n--)f[n]=t&255,t>>>=8;return new Uint8Array(f)}function be(t,e){const f=new Uint8Array(t.length);for(let n=0;n<t.length;n++)f[n]=t[n]^e[n];return f}function S(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function ue(t,e,f,n){A(t),A(e),S(f),e.length>255&&(e=n(_(G("H2C-OVERSIZE-DST-"),e)));const{outputLen:r,blockLen:o}=n,c=Math.ceil(f/r);if(f>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const s=_(e,x(e.length,1)),d=x(0,o),i=x(f,2),a=new Array(c),u=n(_(d,t,i,x(0,1),s));a[0]=n(_(u,x(1,1),s));for(let b=1;b<=c;b++){const p=[be(u,a[b-1]),x(b+1,1),s];a[b]=n(_(...p))}return _(...a).slice(0,f)}function le(t,e,f,n,r){if(A(t),A(e),S(f),e.length>255){const o=Math.ceil(2*n/8);e=r.create({dkLen:o}).update(G("H2C-OVERSIZE-DST-")).update(e).digest()}if(f>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return r.create({dkLen:f}).update(t).update(x(f,2)).update(e).update(x(e.length,1)).digest()}function H(t,e,f){re(f,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:n,k:r,m:o,hash:c,expand:s,DST:d}=f;A(t),S(e);const i=typeof d=="string"?G(d):d,a=n.toString(2).length,u=Math.ceil((a+r)/8),g=e*o*u;let b;if(s==="xmd")b=ue(t,i,g,c);else if(s==="xof")b=le(t,i,g,r,c);else if(s==="_internal_pass")b=t;else throw new Error('expand must be "xmd" or "xof"');const p=new Array(e);for(let m=0;m<e;m++){const I=new Array(o);for(let y=0;y<o;y++){const C=u*(y+m*o),K=b.subarray(C,C+u);I[y]=w(de(K),n)}p[m]=I}return p}function ge(t,e){const f=e.map(n=>Array.from(n).reverse());return(n,r)=>{const[o,c,s,d]=f.map(i=>i.reduce((a,u)=>t.add(t.mul(a,n),u)));return n=t.div(o,c),r=t.mul(r,t.div(s,d)),{x:n,y:r}}}function pe(t,e,f){if(typeof e!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(n,r){const o=H(n,2,{...f,DST:f.DST,...r}),c=t.fromAffine(e(o[0])),s=t.fromAffine(e(o[1])),d=c.add(s).clearCofactor();return d.assertValidity(),d},encodeToCurve(n,r){const o=H(n,1,{...f,DST:f.encodeDST,...r}),c=t.fromAffine(e(o[0])).clearCofactor();return c.assertValidity(),c},mapToCurve(n){if(!Array.isArray(n))throw new Error("mapToCurve: expected array of bigints");for(const o of n)if(typeof o!="bigint")throw new Error("mapToCurve: expected array of bigints");const r=t.fromAffine(e(n)).clearCofactor();return r.assertValidity(),r}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const k=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),R=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),v=BigInt(1),U=BigInt(2),Z=(t,e)=>(t+e/U)/e;function z(t){const e=k,f=BigInt(3),n=BigInt(6),r=BigInt(11),o=BigInt(22),c=BigInt(23),s=BigInt(44),d=BigInt(88),i=t*t*t%e,a=i*i*t%e,u=l(a,f,e)*a%e,g=l(u,f,e)*a%e,b=l(g,U,e)*i%e,p=l(b,r,e)*b%e,m=l(p,o,e)*p%e,I=l(m,s,e)*m%e,y=l(I,d,e)*I%e,C=l(y,s,e)*m%e,K=l(C,f,e)*a%e,ne=l(K,c,e)*p%e,fe=l(ne,n,e)*i%e,W=l(fe,U,e);if(!h.eql(h.sqr(W),t))throw new Error("Cannot find square root");return W}const h=oe(k,void 0,void 0,{sqrt:z}),D=ce({a:BigInt(0),b:BigInt(7),Fp:h,n:R,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=R,f=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-v*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),r=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=f,c=BigInt("0x100000000000000000000000000000000"),s=Z(o*t,e),d=Z(-n*t,e);let i=w(t-s*f-d*r,e),a=w(-s*n-d*o,e);const u=i>c,g=a>c;if(u&&(i=e-i),g&&(a=e-a),i>c||a>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:i,k2neg:g,k2:a}}}},T),J=BigInt(0),X={};function O(t,...e){let f=X[t];if(f===void 0){const n=T(Uint8Array.from(t,r=>r.charCodeAt(0)));f=_(n,n),X[t]=f}return T(_(f,...e))}const q=t=>t.toRawBytes(!0).slice(1),N=t=>Y(t,32),M=t=>w(t,k),P=t=>w(t,R),L=D.ProjectivePoint,me=(t,e,f)=>L.BASE.multiplyAndAddUnsafe(t,e,f);function F(t){let e=D.utils.normPrivateKeyToScalar(t),f=L.fromPrivateKey(e);return{scalar:f.hasEvenY()?e:P(-e),bytes:q(f)}}function Q(t){ae("x",t,v,k);const e=M(t*t),f=M(e*t+BigInt(7));let n=z(f);n%U!==J&&(n=M(-n));const r=new L(t,n,v);return r.assertValidity(),r}const B=V;function $(...t){return P(B(O("BIP0340/challenge",...t)))}function _e(t){return F(t).bytes}function xe(t,e,f=se(32)){const n=E("message",t),{bytes:r,scalar:o}=F(e),c=E("auxRand",f,32),s=N(o^B(O("BIP0340/aux",c))),d=O("BIP0340/nonce",s,r,n),i=P(B(d));if(i===J)throw new Error("sign failed: k is zero");const{bytes:a,scalar:u}=F(i),g=$(a,r,n),b=new Uint8Array(64);if(b.set(a,0),b.set(N(P(u+g*o)),32),!ee(b,n,r))throw new Error("sign: Invalid signature produced");return b}function ee(t,e,f){const n=E("signature",t,64),r=E("message",e),o=E("publicKey",f,32);try{const c=Q(B(o)),s=B(n.subarray(0,32));if(!j(s,v,k))return!1;const d=B(n.subarray(32,64));if(!j(d,v,R))return!1;const i=$(N(s),q(c),r),a=me(c,d,P(-i));return!(!a||!a.hasEvenY()||a.toAffine().x!==s)}catch{return!1}}const we=(()=>({getPublicKey:_e,sign:xe,verify:ee,utils:{randomPrivateKey:D.utils.randomPrivateKey,lift_x:Q,pointToBytes:q,numberToBytesBE:Y,bytesToNumberBE:V,taggedHash:O,mod:w}}))(),he=(()=>ge(h,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(e=>BigInt(e)))))(),ye=(()=>ie(h,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:h.create(BigInt("-11"))}))(),te=(()=>pe(D.ProjectivePoint,t=>{const{x:e,y:f}=ye(h.create(t[0]));return he(e,f)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:h.ORDER,m:1,k:128,expand:"xmd",hash:T}))(),Ie=(()=>te.hashToCurve)(),Ee=(()=>te.encodeToCurve)();export{Ee as encodeToCurve,Ie as hashToCurve,we as schnorr,D as secp256k1};
